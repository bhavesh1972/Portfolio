<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Data Unification Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .card {
            background-color: #ffffff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05), 0 2px 4px rgba(0, 0, 0, 0.04);
        }
        input[type="file"]::file-selector-button {
            background-color: #4f46e5;
            color: white;
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #4338ca;
        }
        .btn-disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="max-w-4xl mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">Universal Data Unification Tool</h1>
            <p class="text-gray-500">Unify up to 3 CSV files using a Python Flask ETL backend.</p>
        </header>

        <div class="card p-6 sm:p-10 rounded-xl">
            <h2 class="text-xl font-semibold mb-6 text-gray-800">1. Upload Source Files</h2>
            <div id="file-upload-container" class="space-y-4 mb-8">
                </div>

            <div class="flex flex-col sm:flex-row items-center justify-between space-y-4 sm:space-y-0 sm:space-x-4">
                <div class="flex items-center space-x-4 w-full sm:w-auto">
                    <label for="output-format" class="text-gray-700">Output Format:</label>
                    <select id="output-format" class="border border-gray-300 rounded-md p-2 shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        </select>
                </div>
                
                <button id="unify-button" 
                        onclick="processUnifyPipeline()" 
                        class="px-6 py-3 bg-indigo-600 text-white font-medium rounded-lg shadow-md hover:bg-indigo-700 transition duration-150 ease-in-out w-full sm:w-auto disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled>
                    <span id="button-text">Unify & Download Data</span>
                </button>
            </div>
        </div>

        <div class="card mt-8 p-6 rounded-xl">
            <h2 class="text-xl font-semibold mb-4 text-gray-800">2. Processing Log</h2>
            <div id="log-output" class="bg-gray-50 p-4 rounded-lg h-40 overflow-y-auto text-sm space-y-1">
                </div>
        </div>
    </div>

    <script>
        const MAX_FILES = 3;
        const PYTHON_API_URL = 'http://127.0.0.1:5000/unify';
        let uploadedFiles = []; // Stores { file, fileType, sourceType } for each slot
        let isProcessing = false;

        const OUTPUT_FORMATS = [
            { id: 'csv', name: 'CSV' },
            { id: 'json', name: 'JSON' }
        ];

        /**
         * Utility to map file names to source types for the ETL
         * @param {string} filename The name of the file.
         * @returns {string} The assigned source type.
         */
        const getSourceType = (filename) => {
            const lowerName = filename.toLowerCase();
            if (lowerName.includes('crm') || lowerName.includes('sales')) {
                return 'CRM_SALES';
            } else if (lowerName.includes('finance') || lowerName.includes('ledger')) {
                return 'FINANCE_LEDGER';
            } else if (lowerName.includes('customer') || lowerName.includes('dim')) {
                return 'CUSTOMER_DIMENSION';
            }
            return 'OTHER';
        };

        /**
         * Simple log status function
         */
        const logStatus = (message, type = 'info') => {
            const logElement = document.getElementById('log-output');
            const entry = document.createElement('p');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            entry.textContent = `[${timestamp}] ${message}`;

            if (type === 'error' || type === 'critical') {
                entry.className = 'text-red-600 font-semibold';
            } else if (type === 'success') {
                entry.className = 'text-green-600 font-semibold';
            } else {
                entry.className = 'text-gray-700';
            }

            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight; // Scroll to bottom
        };

        /**
         * Updates the state of the Unify button (enabled/disabled)
         */
        const updateUnifyButtonState = () => {
            const button = document.getElementById('unify-button');
            const requiredFilesPresent = uploadedFiles.filter(f => f && f.file).length >= 3;
            
            if (requiredFilesPresent && !isProcessing) {
                button.disabled = false;
                button.classList.remove('btn-disabled');
                button.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            } else {
                button.disabled = true;
                button.classList.add('btn-disabled');
                button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            }
        };

        /**
         * Handles file input change events
         */
        const handleFileChange = (event, index) => {
            const file = event.target.files[0];
            if (file) {
                if (file.type !== 'text/csv' && !file.name.toLowerCase().endsWith('.csv')) {
                    logStatus(`Error: ${file.name} is not a CSV file.`, 'error');
                    event.target.value = ''; // Clear the input
                    uploadedFiles[index] = null;
                } else {
                    const sourceType = getSourceType(file.name);
                    uploadedFiles[index] = { file, fileType: file.type, sourceType };
                    logStatus(`File selected: ${file.name} (${sourceType})`);
                }
            } else {
                uploadedFiles[index] = null;
            }
            updateUnifyButtonState();
        };

        /**
         * Creates a file input row with label and file picker
         */
        const createFileInputRow = (index) => {
            const container = document.createElement('div');
            container.className = 'flex items-center space-x-4';
            
            const label = document.createElement('label');
            label.textContent = `File ${index + 1} Type:`;
            label.className = 'text-gray-700 w-32 font-medium';

            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.csv';
            input.className = 'flex-grow border border-gray-300 rounded-md p-2 shadow-sm';
            input.addEventListener('change', (e) => handleFileChange(e, index));

            container.appendChild(label);
            container.appendChild(input);
            return container;
        };

        /**
         * Reads a file and returns its content as an array of objects (CSV parsing)
         */
        const readFileContent = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    try {
                        // Simple CSV to JSON conversion (assumes first row is header)
                        const lines = content.split('\n').filter(line => line.trim() !== '');
                        if (lines.length === 0) {
                            return resolve([]);
                        }
                        
                        // Use a regex to correctly split CSV lines, handling commas inside quotes
                        const headers = lines[0].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(h => h.trim().replace(/"/g, ''));
                        const records = [];

                        for (let i = 1; i < lines.length; i++) {
                            const values = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(v => v.trim().replace(/"/g, ''));
                            if (values.length === headers.length) {
                                const record = {};
                                headers.forEach((header, index) => {
                                    record[header] = values[index];
                                });
                                records.push(record);
                            }
                        }
                        resolve(records);
                    } catch (error) {
                        reject(new Error(`Failed to parse CSV: ${error.message}`));
                    }
                };
                reader.onerror = (e) => reject(new Error('File reading error.'));
                reader.readAsText(file);
            });
        };

        // **********************************************************************
        // ** CRITICAL FIX: JAVASCRIPT DATE STANDARDIZATION **
        // **********************************************************************

        /**
         * Pre-processes date fields in transaction data to a standardized ISO format (YYYY-MM-DDT...).
         * This forces a reliable date format that the Python ETL can consistently parse,
         * resolving the long-standing "Can only use .dt accessor" error.
         * @param {Array<Object>} data The array of transaction records.
         * @returns {Array<Object>} The array with standardized date strings.
         */
        const standardizeDates = (data) => {
            const dateColumns = ['Order_Date', 'Invoice_Date']; 
            return data.map(record => {
                const newRecord = { ...record };
                
                // Identify the date column in the record
                const dateKey = Object.keys(newRecord).find(key => 
                    dateColumns.includes(key) || 
                    (key.toLowerCase().includes('date') && key !== 'Account_Creation_Date') // Exclude dim date
                );

                if (dateKey && newRecord[dateKey]) {
                    const dateValue = newRecord[dateKey];
                    // Clean up common international date formats before parsing
                    const cleanedValue = dateValue.replace(/-/g, '/'); // Use slashes for better New Date() parsing

                    const date = new Date(cleanedValue);
                    if (!isNaN(date)) {
                        // Convert to ISO string (YYYY-MM-DDTHH:MM:SS.000Z)
                        newRecord[dateKey] = date.toISOString(); 
                    } else {
                        // Log a warning if a specific date failed to parse
                        console.warn(`Date standardization failed for value: ${dateValue}`);
                    }
                }
                return newRecord;
            });
        };


        // **********************************************************************
        // ** MAIN PIPELINE FUNCTION (Modified to use standardizeDates) **
        // **********************************************************************

        const processUnifyPipeline = async () => {
            if (isProcessing) return;
            isProcessing = true;
            document.getElementById('button-text').textContent = 'Processing...';
            updateUnifyButtonState();
            logStatus('Starting unification pipeline...', 'info');

            try {
                // 1. Read and parse files
                const selectedFiles = uploadedFiles.filter(f => f && f.file);
                logStatus(`Reading and parsing ${selectedFiles.length} files...`);

                const parsePromises = selectedFiles.map(async (f) => {
                    const data = await readFileContent(f.file);
                    logStatus(`Parsed ${f.file.name} successfully (${data.length} rows).`);
                    return { sourceType: f.sourceType, data: data };
                });

                const parsedFiles = await Promise.all(parsePromises);

                // 2. Prepare data for Python API
                logStatus('Sending prepared data to Python Flask API for processing...');
                
                // --- CRITICAL CHANGE: Apply date standardization here ---
                const dataToSend = {
                    files: parsedFiles.map((file) => {
                        let data = file.data;
                        if (file.sourceType === 'CRM_SALES' || file.sourceType === 'FINANCE_LEDGER') {
                            // Apply JS pre-processing to force ISO date format
                            data = standardizeDates(file.data);
                        }
                        return {
                            sourceType: file.sourceType,
                            data: data
                        };
                    })
                };
                // --- END CRITICAL CHANGE ---

                // 3. Call Python API
                const response = await fetch(PYTHON_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(dataToSend)
                });

                if (!response.ok) {
                    const errorJson = await response.json();
                    throw new Error(errorJson.error || `HTTP error! Status: ${response.status}`);
                }

                const result = await response.json();

                if (result.status === 'success' && result.data) {
                    const unifiedData = result.data;
                    logStatus(`PIPELINE SUCCESS: Unified data received from Python server! (${unifiedData.length} records)`, 'success');
                    
                    if (unifiedData.length > 0) {
                        const formatId = document.getElementById('output-format').value;
                        exportUnifiedData(unifiedData, formatId);
                    } 

                } else {
                    throw new Error('Python server returned an unknown error.');
                }

            } catch (error) {
                logStatus(`CRITICAL ERROR in pipeline: ${error.message}`, 'error');
                console.error('CRITICAL ERROR:', error);
            } finally {
                isProcessing = false;
                document.getElementById('button-text').textContent = 'Unify & Download Data';
                updateUnifyButtonState();
            }
        };

        // **********************************************************************
        // ** CSV/JSON EXPORT FUNCTIONS (No Change Required) **
        // **********************************************************************

        const convertToCsv = (data) => {
            if (data.length === 0) return '';
            const headers = Object.keys(data[0]);
            const csv = [
                headers.join(','), // Header row
                ...data.map(row => headers.map(header => {
                    const value = row[header];
                    // Escape quotes and ensure complex values are quoted
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                }).join(','))
            ].join('\n');
            return csv;
        };

        const exportUnifiedData = (data, formatId) => {
            let content;
            let mimeType;
            let extension;

            if (formatId === 'csv') {
                content = convertToCsv(data);
                mimeType = 'text/csv';
                extension = 'csv';
            } else { // json
                content = JSON.stringify(data, null, 2);
                mimeType = 'application/json';
                extension = 'json';
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `unified_data_${new Date().toISOString().slice(0, 10)}.${extension}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            logStatus(`Data successfully exported as ${formatId.toUpperCase()}.`, 'success');
        };

        /**
         * Initialization function to set up the UI.
         */
        const initializeApp = () => {
            const container = document.getElementById('file-upload-container');
            for (let i = 0; i < MAX_FILES; i++) {
                container.appendChild(createFileInputRow(i));
                uploadedFiles.push(null); 
            }

            // Populate the output format dropdown
            const outputSelect = document.getElementById('output-format');
            OUTPUT_FORMATS.forEach(format => {
                const option = document.createElement('option');
                option.value = format.id;
                option.textContent = format.name;
                outputSelect.appendChild(option);
            });
            
            updateUnifyButtonState();
            logStatus('Application loaded. Please select your source files.', 'info');
        };

        window.onload = initializeApp;
    </script>
</body>

</html>
